import re

TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

class ABFile():
    def __init__(self, filename, create):
        # Validate the filename before proceeding
        if not self._validate_filename(filename):
            raise ValueError(f"Invalid filename: {filename}")
        
        # globals
        mycontext['debug'] = False
        # local (per object) reference to the underlying file
        self.Afn = filename + '.a'  # Backup file
        self.Bfn = filename + '.b'  # Writable file

        # Ensure atomic creation of both files
        if create:
            self.Afile = openfile(self.Afn, create)
            self.Bfile = openfile(self.Bfn, create)
            # Initialize the A file with 'SE' as a marker of file integrity if it's newly created
            if create:
                self.Afile.writeat('SE', 0)

    def _validate_filename(self, filename):
        """
        Validate the filename according to the following rules:
        - Filenames must contain only lowercase letters, numbers, hyphen, underscore, and period.
        - Filenames cannot be '.', '..', or the blank string.
        - Filenames cannot start with a period.
        - Filenames must be no more than 120 characters long.
        """
        if not filename or filename in ('.', '..') or filename.startswith('.'):
            return False
        if len(filename) > 120:
            return False
        # Only allow lowercase letters, numbers, hyphen, underscore, and period
        if not re.match(r'^[a-z0-9\-_\.]+$', filename):
            return False
        return True

    def _is_valid(self, file):
        """
        This helper method checks if a file is valid by ensuring that it
        starts with 'S' and ends with 'E'.
        """
        size = file.getsize()
        if size < 2:
            return False
        
        start_char = file.readat(1, 0)
        end_char = file.readat(1, size - 1)
        
        return start_char == 'S' and end_char == 'E'

    def writeat(self, data, offset):
        """
        Allow all writes, even if the data is temporarily invalid.
        """
        # Write to the B file (writable file) without blocking or error
        self.Bfile.writeat(data, offset)

    def readat(self, bytes, offset):
        # Read from the A file (backup file)
        return self.Afile.readat(bytes, offset)

    def close(self):
        """
        When closing the file, check if the B file is valid (starts with 'S' and ends with 'E').
        If valid, copy B to A. If not, discard B.

awesomestudent@awesomestudent-ISP:~/repy_v2/RUNNABLE$ python3 repy.py encasementlib.r2py my_security_layer.r2py my_application.r2py
---
Uncaught exception!
 ---
Following is a full traceback, and a user traceback.
The user traceback excludes non-user modules. The most recent call is displayed last.

Full debugging traceback:
  "repy.py", line 438, in main
  "/home/awesomestudent/repy_v2/RUNNABLE/virtual_namespace.py", line 112, in evaluate
  "/home/awesomestudent/repy_v2/RUNNABLE/safe.py", line 583, in safe_run
  "encasementlib.r2py", line 244, in <module>
  "encasementlib.r2py", line 229, in secure_dispatch
  "/home/awesomestudent/repy_v2/RUNNABLE/namespace.py", line 797, in __do_func_call
  "/home/awesomestudent/repy_v2/RUNNABLE/namespace.py", line 1063, in wrapped_function
  "/home/awesomestudent/repy_v2/RUNNABLE/virtual_namespace.py", line 112, in evaluate
  "/home/awesomestudent/repy_v2/RUNNABLE/safe.py", line 583, in safe_run
  "my_security_layer.r2py", line 31, in <module>
  "encasementlib.r2py", line 179, in _secure_dispatch_closure
  "encasementlib.r2py", line 229, in secure_dispatch
  "/home/awesomestudent/repy_v2/RUNNABLE/namespace.py", line 797, in __do_func_call
  "/home/awesomestudent/repy_v2/RUNNABLE/namespace.py", line 1063, in wrapped_function
  "/home/awesomestudent/repy_v2/RUNNABLE/virtual_namespace.py", line 112, in evaluate
  "/home/awesomestudent/repy_v2/RUNNABLE/safe.py", line 583, in safe_run
  "my_application.r2py", line 5, in <module>

User traceback:
  "encasementlib.r2py", line 244, in <module>
  "encasementlib.r2py", line 229, in secure_dispatch
  "my_security_layer.r2py", line 31, in <module>
  "encasementlib.r2py", line 179, in _secure_dispatch_closure
  "encasementlib.r2py", line 229, in secure_dispatch
  "my_application.r2py", line 5, in <module>

Exception (with class 'NameError'): name 'ABopenfile' is not defined
---
Terminated


        """
        if self._is_valid(self.Bfile):
            # Copy contents of B to A
            self.Afile.close()
            self.Afile = openfile(self.Afn, False)  # Open the A file for writing
            self.Afile.truncate(0)  # Clear existing contents of A

            # Read the contents of B and write them into A
            data = self.Bfile.readat(self.Bfile.getsize(), 0)
            self.Afile.writeat(data, 0)
        else:
            # Discard B if it's invalid, raise an error to indicate tampering
            raise ValueError("B file is invalid. It must start with 'S' and end with 'E'.")
        
        # Close both files
        self.Afile.close()
        self.Bfile.close()

def ABopenfile(filename, create):
    """
    ABopenfile opens the ABFile object and raises an error if any violation occurs.
    """
    return ABFile(filename, create)


# The code here sets up type checking and variable hiding for you.
# You should not need to change anything below here.
sec_file_def = {
    "obj-type": ABFile,
    "name": "ABFile",
    "writeat": {"type": "func", "args": (str, int), "exceptions": Exception, "return": (int, type(None)), "target": ABFile.writeat},
    "readat": {"type": "func", "args": ((int, type(None)), (int)), "exceptions": Exception, "return": str, "target": ABFile.readat},
    "close": {"type": "func", "args": None, "exceptions": None, "return": (bool, type(None)), "target": ABFile.close}
}

CHILD_CONTEXT_DEF["ABopenfile"] = {TYPE: OBJC, ARGS: (str, bool), EXCP: Exception, RETURN: sec_file_def, TARGET: ABopenfile}

# Execute the user code
secure_dispatch_module()
